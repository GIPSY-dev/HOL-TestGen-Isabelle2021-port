(*****************************************************************************
 * HOL-TestGen --- theorem-prover based test case generation
 *                 http://www.brucker.ch/projects/hol-testgen/
 *
 * z3_model.ML --- a parser for models generated by Z3.
 * This file is part of HOL-TestGen.
 *
 * Copyright (c) 2005-2010 ETH Zurich, Switzerland
 *               2008-2013 Achim D. Brucker, Germany
 *               2009-2013 Universite Paris-Sud, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************)
(* $Id:$ *)

signature Z3_MODEL =
sig
  val parse_model : SMT_Translate.replay_data -> string list -> SMT_patch_Solver.parsed_model
end



structure Z3_Model : Z3_MODEL =
struct

open SMTLIB_Proof


(* Extracting definitions of a variable or a function symbol *)

(* Non-functional variables: the codomain is empty *)
fun get_def ctxt smt_ctxt (SMTLIB.S [SMTLIB.Sym "define-fun", n, SMTLIB.S [], _, v]) =
  let
    (* Parsing the variable *)
    val (x, smt_ctxt2) = term_of n smt_ctxt
    (* For debugging *)
    (* val _ = tracing ("Variable: "^(Pretty.string_of (Syntax.pretty_term ctxt x))) *)
    (* Parsing its value *)
    val (t, smt_ctxt3) = term_of v smt_ctxt2
    (* For debugging *)
    (* val _ = tracing ("Value: "^(Pretty.string_of (Syntax.pretty_term ctxt t))) *)
  in
    SOME (x, t, smt_ctxt3)
  end

  (* UNDER PROGRESS *)
  (* Functional variables: the codomain is nonempty *)
  | get_def ctxt smt_ctxt (SMTLIB.S [SMTLIB.Sym "define-fun", n, SMTLIB.S (absname::args), _, v]) = NONE  (* UNDER PROGRESS *)

  (* Other definitions: dismissed for the moment *)
  | get_def _ _ v = NONE


(* Extracting all the definitions *)

fun get_defs ctxt smt_ctxt smtlib_defs =
  snd (
    List.foldl (fn (def, (smt_ctxt', acc)) =>
                   case get_def ctxt smt_ctxt' def of
                     NONE => (smt_ctxt', acc)
                   | SOME (a, b, smt_ctxt'') => (smt_ctxt'', (a,b)::acc))
    (smt_ctxt, []) smtlib_defs
  )


(* Top-level function to interpret Z3 models *)

fun parse_model_main ctxt typs funs lines =
  let
    (* val _ = tracing "Lines:\n"
    val _ = List.app (fn l => tracing (l^"")) lines *)
    val res =
      case SMTLIB.parse lines of
          SMTLIB.S ((SMTLIB.Sym "model") :: vs) => get_defs ctxt (empty_context ctxt typs funs) vs
        | ts => raise SMTLIB_PARSE ("bad Z3 model declaration", ts)
  in
    {const_defs = res}
  end

fun parse_model
  ({context = ctxt, typs, terms, ...} : SMT_Translate.replay_data)
  output =
    parse_model_main ctxt typs terms output

end
